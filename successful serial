#include <khepera/khepera.h>
#include <signal.h>

#define PORT 3000

static knet_dev_t * dsPic;
static int quitReq = 0; // quit variable for loop

static void ctrlc_handler( int sig ) 
{
  quitReq = 1;
  
  kh4_set_speed(0 ,0 ,dsPic); // stop robot
  kh4_SetMode( kh4RegIdle,dsPic );
  
  kh4_SetRGBLeds(0,0,0,0,0,0,0,0,0,dsPic); // clear rgb leds because consumes energy
  
  kb_change_term_mode(0); // revert to original terminal if called
  
  exit(0);
}

int main(int argc, char *argv[]) {
  int rc;

  /* Set the libkhepera debug level - Highly recommended for development. */
  kb_set_debug_level(2);

  
  
    /* Init the khepera library */
  if((rc = kb_init( argc , argv )) < 0 )
    return 1;

  struct timeval startt,endt;
  
  
  /*------------------- Time Value Difference -----------*/
  /* Compute time difference

   * \param difference difference between the two times, in structure timeval type
   * \param end_time end time
   * \param start_time start time
   *
   * \return difference between the two times in [us] */
  long long timeval_diff(struct timeval *difference, struct timeval *end_time, struct timeval *start_time)
  {
  	struct timeval temp_diff;

  	if(difference == NULL) {
  		difference =& temp_diff;
  	}

  	difference -> tv_sec  = end_time -> tv_sec  - start_time -> tv_sec ;
  	difference -> tv_usec = end_time -> tv_usec - start_time -> tv_usec;

  	/* Using while instead of if below makes the code slightly more robust. */

  	while(difference -> tv_usec < 0) {
  		difference -> tv_usec += 1000000;
      	difference -> tv_sec  -= 1;
  	}

  	return 1000000LL * difference -> tv_sec + difference -> tv_usec;
  } /* timeval_diff() */

  
  
  

  dsPic  = knet_open( "Khepera4:dsPic" , KNET_BUS_I2C , 0 , NULL );
	/* ADD YOUR CODE HERE */
  signal( SIGINT , ctrlc_handler ); // set signal for catching ctrl-c 
  kb_change_term_mode(1);
  kh4_SetMode(kh4RegSpeed,dsPic);
  
  
  /* --------------------------------------------------- */
    	/* Socket Communication/Transmittion Code */
    	int server_fd, new_socket, valread; 
      struct sockaddr_in address; 
      int opt = 1; 
      int addrlen = sizeof(address); 
      char sock_buffer[1024] = {0}; 
      // char *hello = "Hello from server"; 
           
      // Creating socket file descriptor 
      if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
      { 
      	perror("socket failed"); 
          exit(EXIT_FAILURE); 
      } 
           
      // Forcefully attaching socket to the port 3000
      if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) 
      { 
      	perror("setsockopt"); 
          exit(EXIT_FAILURE); 
      } 
      address.sin_family = AF_INET; 
      address.sin_addr.s_addr = INADDR_ANY; 
      address.sin_port = htons( PORT ); 
           
      // Forcefully attaching socket to the port 3000 
      if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) 
      { 
      	perror("bind failed"); 
          exit(EXIT_FAILURE); 
      } 
      if (listen(server_fd, 3) < 0) 
      { 
          perror("listen"); 
          exit(EXIT_FAILURE); 
      } 
      if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) 
      { 
          perror("accept"); 
          exit(EXIT_FAILURE); 
      } 
      // valread = read( new_socket , sock_buffer, 1024); 
      // printf("%s\n",sock_buffer ); 
      // send(new_socket , hello , strlen(hello) , 0 ); 
      // printf("Hello message sent\n"); 
      /* --------------------------Socket Code End------------------------- */




  
  char acc_Buffer[100];
  double dvalX, dmeanX;
  
  gettimeofday(&startt,0x0);

  while(quitReq == 0) {

	  gettimeofday(&endt,0x0);
	  kh4_measure_acc((char *)acc_Buffer, dsPic);
	  long long t = timeval_diff(NULL, &endt, &startt);
	  long double T = t / 1000000.0;
	  //printf("LibKhepera Template Program\r\n"); 
	  printf("\nAcceleration sensor on X axis: ");
	   		  
	  dmeanX = 0;
	   		  
	  int i;
	   		  
	  for (i = 0; i < 10; i++) {
		  dvalX = ((short)(acc_Buffer[i * 2] | acc_Buffer[ i * 2 + 1] << 8) >> 4) / 1000.0;
		  dmeanX += dvalX;
	  }
	   		  						
	  dvalX = dmeanX / 10.0;
	  printf(" %5.2f \n",dvalX);
	   
	  char text[2048];
	  sprintf(text, "%2.4f", T);
	  sprintf(text + strlen(text), "x");

	  char textXAcc[2048];
	  sprintf(textXAcc, "%2.4f", dvalX);
	  sprintf(text + strlen(text), textXAcc);
	  sprintf(text + strlen(text), "y");
	  	  char *p = text;
	  	  int len = strlen(p);


	  send(new_socket , p, len , 0 );




	  //send(new_socket, c_xAcc, len, 0);

	   				//send(new_socket , len, sizeof(len), 0);
	   				//send(new_socket, &dvalX, sizeof((double)dvalX), 1);
	   				  
	  //usleep(20000); // figure delay number out
	  
	  
  }

 return 0;  
}
